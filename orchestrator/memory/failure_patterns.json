{
  "version": "1.0.0",
  "last_updated": "2025-06-18",
  "patterns": [
    {
      "id": "monolithic-component-pattern",
      "name": "Monolithic Component Anti-Pattern",
      "category": "frontend",
      "description": "Large components with multiple responsibilities",
      "failure_rate": 0.78,
      "common_issues": [
        "Components exceed 600 lines",
        "Multiple responsibilities in single component",
        "Difficult to test",
        "Poor reusability"
      ],
      "warning_signs": [
        "Component files > 500 lines",
        "Multiple useEffect hooks for unrelated concerns",
        "Prop drilling more than 2 levels",
        "Mixed business logic and UI logic"
      ],
      "solutions": [
        "Break into smaller components",
        "Extract custom hooks",
        "Use context or state management",
        "Separate business logic into services"
      ]
    },
    {
      "id": "callback-hell-pattern",
      "name": "Callback Hell Anti-Pattern",
      "category": "backend",
      "description": "Nested callbacks creating unreadable code",
      "failure_rate": 0.85,
      "common_issues": [
        "Deeply nested callbacks",
        "Error handling complexity",
        "Difficult to debug",
        "Poor code readability"
      ],
      "warning_signs": [
        "More than 3 levels of callback nesting",
        "Inconsistent error handling",
        "Pyramid-shaped code structure"
      ],
      "solutions": [
        "Use async/await",
        "Implement promise chaining",
        "Use utility functions for error handling",
        "Consider async libraries like async.js"
      ]
    },
    {
      "id": "god-object-pattern",
      "name": "God Object Anti-Pattern",
      "category": "general",
      "description": "Single object knowing too much about the system",
      "failure_rate": 0.72,
      "common_issues": [
        "Objects with too many responsibilities",
        "Tight coupling between components",
        "Difficult to maintain and test",
        "Single point of failure"
      ],
      "warning_signs": [
        "Classes/modules > 1000 lines",
        "More than 10 methods per class",
        "Methods with many parameters",
        "High cyclomatic complexity"
      ],
      "solutions": [
        "Apply single responsibility principle",
        "Extract smaller classes/modules",
        "Use dependency injection",
        "Implement interface segregation"
      ]
    },
    {
      "id": "hardcoded-configuration-pattern",
      "name": "Hardcoded Configuration Anti-Pattern",
      "category": "general",
      "description": "Configuration values embedded in code",
      "failure_rate": 0.68,
      "common_issues": [
        "Environment-specific values in code",
        "Difficult deployment across environments",
        "Security risks with sensitive data",
        "Poor maintainability"
      ],
      "warning_signs": [
        "Database URLs in source code",
        "API keys embedded in files",
        "Hardcoded file paths",
        "Environment-specific logic"
      ],
      "solutions": [
        "Use environment variables",
        "Create configuration files",
        "Implement secret management",
        "Use different configs per environment"
      ]
    },
    {
      "id": "prisma-schema-code-mismatch-2025-12",
      "name": "Prisma Schema Code Mismatch",
      "description": "Compilation errors due to Prisma Client types not matching the actual usage in code because of missing schema fields or outdated client.",
      "category": "backend",
      "failure_rate": 0.6,
      "common_issues": [
        "Property does not exist on type errors",
        "Type mismatch assignments",
        "Build failure after code updates"
      ],
      "solutions": [
        "Identify missing or mismatched fields in schema.prisma",
        "Update schema.prisma to match code usage",
        "Run 'prisma generate' to update client types"
      ],
      "warning_signs": [
        "TS2339 Property does not exist errors",
        "TS2322 Type assignability errors",
        "New features implemented without schema updates"
      ]
    },
    {
      "id": "database-unique-constraint-generation-2025-12",
      "name": "Unique Constraint Violation on Generated Values",
      "description": "Database unique constraint failure when generating values (slug, username, etc.) without verifying uniqueness in database",
      "category": "backend",
      "failure_rate": 0.75,
      "common_issues": [
        "HTTP 500: Unique constraint failed on field X",
        "Registration fails when input produces duplicate generated values",
        "Issue appears when multiple users have similar input (e.g., same name)"
      ],
      "symptoms": [
        "Prisma create/update throws 'Unique constraint failed on the fields' error",
        "Works fine for unique inputs but fails for common ones",
        "Multiple users with same first name/slug cause collision"
      ],
      "root_cause": "Generating unique values (slug, username) from user input without checking database for existing values first",
      "solution": "Before creating record, check if generated value already exists and append counter/suffix if needed. Implement helper function that loops until unique value found",
      "technologies": ["Prisma", "PostgreSQL", "Node.js", "Express.js"],
      "prevention": "Always validate uniqueness against database when generating derived values from user input",
      "code_example": "async function generateUniqueSlug(baseSlug: string) { let slug = baseSlug; let counter = 1; while(await db.user.findUnique({where: {slug}})) { slug = `${baseSlug}${counter}`; counter++; } return slug; }"
    }
  ],
  "insights": {
    "most_problematic_patterns": ["monolithic-component-pattern", "callback-hell-pattern"],
    "common_failure_causes": [
      "Lack of architectural planning",
      "Rushing to implementation",
      "Ignoring code organization",
      "Poor separation of concerns",
      "Inadequate testing"
    ],
    "prevention_strategies": [
      "Start with architectural design",
      "Implement code reviews",
      "Use linting rules",
      "Regular refactoring",
      "Comprehensive testing"
    ]
  }
}
